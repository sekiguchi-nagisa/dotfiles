source $MODULE_DIR/completion

# $COMP_HOOK
function _carapace_comp(m: Module, argv: [String], n: Int): Candidates? {
    var cmd = $argv[0]
    var compline = $argv.join(' ')
    var wordToken = $argv.peek()
    if $n >= $argv.size() {
        $compline += ' '
        $wordToken = ""
    }
    if $wordToken.endsWith('\') && !$wordToken.dequote().endsWith('\') { # ex. --arg\
        var arg = $wordToken.slice(0, -1)  # force remove trailing backslash (carapace do not remove trailing backslash)
        $argv[-1] = $arg
        $compline = $argv.join(' ')
    }

    var ret : Candidates
    (if (echo ${compline}"''" | xargs echo &>> /dev/null) {
        echo ${compline}"''" | xargs carapace $cmd fish
    } elif (echo ${compline} | sed "s/\$/'/" | xargs echo &>> /dev/null) {
        echo ${compline} | sed "s/\$/'/" | xargs carapace $cmd fish
    } else {
        echo ${compline} | sed 's/$/"/' | xargs carapace $cmd fish
    }) | for line in $STDIN {
        var ss = $line.split($'\t')
        $ret.add($ss[0], $ss.get(1))
    }
    $ret.quote($wordToken)
    return $ret
}

if (command -v carapace &>> /dev/null && command -v xargs &>> /dev/null) {
    importenv CARAPACE_IGNORE : ""
    let ignores = $CARAPACE_IGNORE.split(':').sort()
    carapace --list | for line in $STDIN {
        var cmd = $line.split(' ')[0]
        $ignores.searchSorted($cmd) > -1 && continue
        if var old = $compAdd($cmd, $_carapace_comp) {  # do not overwrite already defined completer
            $compAdd($cmd, $old)
        }
    }
}